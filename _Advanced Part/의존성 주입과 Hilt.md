
## 의존성 주입 

객체지향 프로그래밍의 개념 중 하나로, 
객체가 필요로 하는 다른 객체를 직접 생성하지 않고 외부에서 전달 받는 형식입니다.
안드로이드에서 의존성 주입을 사용하면 액티비티, 뷰 모델, 서비스 등 여러 컴포넌트에서 공통으로
사용되는 데이터 베이스, 네트워크와 같은 객체를 한 곳에서 관리할 수 있습니다.
객체 간의 결합도를 낮추고, 코드의 중복과 유지보수, 테스트 용이성을 증가시킵니다.
SOLID 원칙의 의존 역전 원칙과 관련되어 있으며, 추상화에 의존해야 하며 구체화에 의존하지 않는 것을 원칙
직접 구현 된 객체 같은 저수준 모듈보다 인터페이스 같은 추상화 된 고수준 모듈을 활용해야 합니다.


### 안드로이드의 의존성 주입

- Dagger, Koin, Hilt
- Hilt
  - Dagger2 기반 라이브러리로, 사용하기 쉽고 표준화 된 사용 방법을 제시해 줍니다.
  - 안드로이드 클래스에 최적화 되어있기 때문에, 안드로이드 클래스 외에는 사용하기 어렵다는 단점이 있습니다.

### Hilt Component
- Application에 적용하는 @HiltAndroidApp
- ViewModel에 적용하는 @HiltViewModel
- Activity, Fragment, View, Service, BroadcastReceiver 같은 컴포넌트에서는 @AndroidEntryPoint

### Hilt Scope
- Hilt UnScoped 상태, 앱이 객체를 요청할 때마다 새로운 객체가 만들어 집니다.
- 이를 방지하기 위해서 각 의존 객체는 Scope라는 이름의 생명 주기를 가지게 됩니다.
- 이 스코프의 범위를 나타내는 것이 Scope 어노테이션입니다
- 앱 전체에 하나의 객체만 생성하는 @Singleton, Activity에 하나의 객체를 가지는 @ActivityScoped
- 그 외에 뷰 모델 등 컴포넌트 종속 관계에 따라서 상위 Scope를 가진 의존 객체에 접근이 가능해 집니다.

### Hilt 필드 주입 
- 주입 받을 클래스에 @AndroidEntryPoint 어노테이션을 붙임
- 의존성을 제공받는 필드에 @Inject 어노테이션으로 바인딩을 완료

### Hilt 생성자 주입
- 의존 객체에 @Inject 어노테이션을 붙이고, constructor() 생성자 파라미터를 통해서 의존성 주입
- constructor Inject을 사용하면 생성 시에 Hilt에서 어떤 객체가 필요한지 알 수있으며, 개발자도 확인 가능하다.

### 생성자 주입이 불가능한 경우
- 인터페이스에서는 constructor Inject가 사용 불가능하다. -> Hilt에서 인터페이스 객체를 어떻게 생성할 지 모르기 때문이다.
- 외부 라이브러리 (Retrfit) 에서도 사용이 불가능하다. -> 자신이 만든 클래스가 아닌 곳에서는 불가능
- **해결 방법**
  - 두 가지 케이스를 해결하기 위에서 @HiltModule을 사용할 수 있다.

### Module
- 의존 객체를 담는 클래스로 Component 안에 모듈을 설치하고, 그 모듈 내부의 의존 객체를 필요로 하는 곳에 주입
- 모듈 안의 모든 객체는 다른 곳에 주입할 수 있다.
- @InstallIn 어노테이션으로 Hilt의 모듈을 지정할 수 있으며, 스코프를 지정해서 생명주기를 설정 가능하다.

- @Provides : 외부 라이브러리를 이용해서 객체를 생성할 때 사용
- @Binds : 인터페이스를 의존 객체로 제공하는 경우 사용 (abstract 함수로 정의 -> 추상화)

### Qualifier 한정자
- 같은 유형의 여러개의 결합이 있는 경우, Hilt에서는 어떤 구현을 해야하는지 모름
- 한정자를 사용해서 네이밍을 지정한 후 모듈에 적용할 수 있음

### @Retention
- Retention 어노테이션을 통해서 어노테이션의 라이프 사이클을 지정할 수 있음 