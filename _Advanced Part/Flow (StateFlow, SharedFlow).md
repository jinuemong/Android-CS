
### Flow
- 코루틴에 정식으로 추가 된 인터페이스로 RxJava의 옵저버와 같은 기능을 함 
- 코루틴 상에서 스트림 작업을 지원하는 구현체로 suspend function을 보완하기 위해서 나옴
- suspend function은 하나의 결과물을 던지고, 플로우는 스트림을 통해서 여러 개의 결과를 던질 수 있음

### Suspend Function
- thread가 block 될 경우, 해당 스레드는 다른 작업을 할 수 없는 블락 상태가 됩니다.
- suspend function을 사용할 경우 blocked 된 상태에 놓일 때 그 작업을 일단 중단하고 다른 스레드에서 다른 작업 수행
- 하나의 스레드에서 여러 개의 코루틴을 실행할 수있으며, 메모리 절약이 가능한 경량 스레드의 일종임

### 단점
- 화면 돌리기 등의 이벤트 발생 시 UI가 사용하는 데이터가 초기화되어 API 재요청이 발생합니다.
- viewModel에 저장한 후 UI가 관찰하는 방법도 있지만 비효율적인 보일러 플레이트 발생합니다.
- 위 단점을 해결하기 위해서 HotFlow로 전환해야 합니다.
- Flow를 Cold Flow라고 하며, 콜렉터가 있을 때만 데이터를 방출할 수 있습니다. (생성 후 구독 필수)
- HotFlow를 전환하면 콜렉터가 없어도 데이터를 방출할 수 있는 장점을 가지게 됩니다.(구독하지 않아도 데이터 전달)

### 콜드 Flow -> Hot Flow
일반적인 플로우 사용 시 새로운 구독을 할 때마다 repository의 플로우 빌더 블록에서 플로우 방출을 
트리거하여 리소스를 낭비할 수 있기 때문에 뷰 모델에서는 Hot Flow를 사용자에게 노출해야 합니다.
- 2가지 방법
  - #### Flow를 수집하여 State or Shared Flow로 push
    - 두 가지 모두 Flow에 최적으로 데이터 State를 업데이트해서 여러 소비자에게 내보닙니다.독
  - ### StateIn 확장 함수를 활용 
    - started 인자를 통해 구성 변경이 발생하는 경우 플로우 스트림이 다시 구독되지 않도록 보장합니다.

### StateFlow
- 최신 및 새로운 상태를 여러 콜렉터에게 업데이트 시켜주며, MutableStateFlow 클래스에 value 속성에 값 할당
- flow를 StateFlow로 변환하려 stateIn 중간 연산자를 사용하며, 효율적이고 간단하다는 장점이 있습니다.
- 관찰이 필요한 가변상태를 유지해야 하는 클래스에 적합하며 LiveData와 옵저버 데이터 홀더 클래스를 사용하는 유사성이 있습니다.

### 라이브데이터와 StateFlow의 차이점
- StateFlow는 생성할 때 생성자에 전달되는 초기 State가 필요하며, LiveData는 필요 없음 
- 라이브 데이터의 옵저버는 뷰가 stooped 상태가 될 때 자동으로 소비자 등록을 해제하는 단점이 있습니다.
- 반면에 StateFlow는 콜렉팅 하는 것으로 이를 방지할 수 있습니다. 
### SharedFlow
- State Flow로 전환 가능한 플로우이며, 생성 된 이후 누군가 소비를 시작하면 데이터를 발행합니다.
- 이벤트 헨들링에 적합하며 시간이 지남에 따라 동일한 이벤트를 트리거하는 경우에 사용합니다.
- 스낵바, 탐색, 네트워크 연결 상태 등 동일한 값을 재방출 하는 형식으로 진행됩니다.
